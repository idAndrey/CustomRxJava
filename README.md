# CustomRxJava
Реализация пользовательской версии библиотеки RxJava на основе концепции реактивного программирования.  
Проект включает базовые компоненты реактивного потока, поддерживает асинхронное выполнение, обработку ошибок и предоставляет операторы преобразования данных  

## Содержание
1. [Описание проекта](#описание-проекта)
2. [Реализация базовых компонентов](#реализация-базовых-компонентов)
3. [Операторы преобразования данных](#операторы-преобразования-данных)
4. [Управление потоками выполнения](#управление-потоками-выполнения)
5. [Управление подписками и дополнительные операторы](#управление-подписками-и-дополнительные-операторы)
6. [Тестирование](#тестирование)

---

## Описание проекта
Пользовательская версия библиотеки RxJava представляет собой систему реактивных потоков с возможностью управления потоками выполнения (Schedulers) и обработки событий с использованием паттерна «Наблюдатель» (Observer pattern).

### Зависимости

* Java 21
* Maven 3.9.9
* SLF4J API 2.0.16
* Logback 1.5.13
* JUnit 5.9.2

### Установка и запуск

1. Склонировать репозиторий:

   ```bash
   git clone https://github.com/idAndrey/CustomRxJava.git
   cd CustomRxJava
   ```
2. Собрать проект:

   ```bash
   mvn clean install
   ```
3. Запустить тесты
   ```bash
   mvn clean test
   ```
4. Запустить демонстрационную программу:
   ```bash
   java -jar target/customrxjava-1.0-SNAPSHOT.jar
   ```
   или
   ```bash
   mvn exec:java
   ```
---
## Реализация базовых компонентов

Интерфейс `Observer` с методами:
* onNext(T item) — получает элементы потока
* onError(Throwable t) — обрабатывает ошибки
* onComplete() — вызывается при завершении потока  

Класс `Observable` с поддержкой подписки (subscribe).  
В классе `Observable` реализован статический метод `create()`, позволяющий создавать объекты `Observable`.
Класс `Observable` отвечает за создание источника данных и публикацию данных подписчикам в порядке, в котором элементы потока данных были созданы.

---

## Операторы преобразования данных
В пользовательской версии библиотеки RxJava реализованы следующие операторы преобразования данных:
* оператор `map(Function mapper)`, который преобразует поток данных
* оператор `filter(Predicate predicate)`, который фильтрует элементы потока данных  
* оператор `flatMap(Function mapper)`, который объединяет два разных потока и преобразует элементы в новый `Observable`  

Операторы встроены в класс `Observable`

---

## Управление потоками выполнения

Пользовательская версия библиотеки RxJava предоставляет следующие классы:

* IOThreadScheduler
* ComputationScheduler
* SingleThreadScheduler

который реализуют интерфейс `Scheduler`
```java
public interface Scheduler {
    void execute(Runnable task);
}
```

Данные классы обеспечивают возможность управления потоком выполнения для `Observable` по аналогии соответственно с:
* Schedulers.io()
* Schedulers.computation()
* Schedulers.single()

Для поддержки управления потоками в классе `Observable` реализованы методы: 
* subscribeOn(Scheduler scheduler), чтобы подписка выполнялась в заданном потоке;
* observeOn(Scheduler scheduler), чтобы обработка элементов происходила в нужном потоке.  

### Применение различных Shedulers

1. **IOThreadScheduler**:
   * реализация основана на `CachedThreadPool`
   * оптимален для решения задач, связанных с вводом/выводом: работа с сетью, файловые операции
   * новые потоки запускаются по мере необходимости
   * неактивные потоки используются повторно после простоя

2. **ComputationScheduler**:
   * основан на применении `FixedThreadPool`
   * количество потоков в пуле устанавливается равным количеству ядер процессора, доступных виртуальной машине Java (Runtime.getRuntime().availableProcessors())
   * подходит для решения вычислительных задач, интенсивно использующих процессорное время: математические или алгоритмические расчёты
   * фиксированный размер пула предотвращает избыточную конкуренцию за CPU

3. **SingleThreadScheduler**:
   * используется единственный потоком `SingleThreadExecutor`
   * гарантирует последовательное выполнение в одном потоке
   * применяется для выполнения операций в строго заданной последовательности (например, обновление интерфейса пользователя)

---

## Управление подписками и дополнительные операторы

Для отмены подписки реализован интерфейс `Disposable`:
```java
public interface Disposable {
    void dispose();
    boolean isDisposed();
}
```
Реализован оператор `flatMap(Function<t, observable<r="">> mapper)`, который преобразует элементы в новый Observable.  

При этом обработка ошибок осуществляется путём их передачи в метод onError() с последующим распространением по цепочке операторов.  

---

## Тестирование

Примеры использования пользовательской версии библиотеки RxJava представлены в **демонстрационной программе** app.Application.  
Запуск программы:  

```bash
   java -jar target/customrxjava-1.0-SNAPSHOT.jar
```
или  
```bash
   mvn exec:java
```


### Тесты для ключевых компонентов системы

В класс `BaseCoreTest` проверяется:
* эмиссия элементов потока данных
* завершение эмиссии

### Тестирование работы Schedulers в многопоточной среде

В класс `SchedulerTest` проверяется:
* подписка и обработка элементов в потоках, отличных от текущего (main)
* последовательное выполнение обработки элементов потока данных в `SingleThreadScheduler`

### Тестирование работы операторов

Правильность выполнения операторов преобразования данных проверяется в классе `OperatorTest`:
* map
* filter
* flatMap

### Тестирование обработки ошибок

Корректность обработки ошибок проверяется в классе `ErrorHandlingTest`

---

## Поддержка
Если у вас возникли вопросы по проекту или сложности при его запуске, создайте
[обсуждение](https://github.com/idAndrey/issues/new/choose) в данном репозитории или свяжитесь с разработчиком по электронной почте <a href="mailto:mail@example.com"><ermakov.andrey@ya.ru></a> или телеграм [Андрей Ермаков](https://t.me/pc022979700).  
